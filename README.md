# strack
Static stack analysis tool for embedded C.  
Currently supports analysis of plain C compiled with arm-none-eabi-gcc toolchain.
Support for C++ and/or other compiler toolchains may be added in the future.  Difficulties of analyzing C++ outlined in C++ section

## Usage

### analyze  
Run Stack Anylysis  
`python3 <path>/strack.py analyze object1.o object2.o ...`  
Easiest way to run this is to run it from your makefile using the same object list that is given to the linker.
### report  
Print Stack Report to Console  
`python3 <path>/strack.py report <path>/out/strack_report.json`  
strack_report.json is generated by running the analyze command

### Example Config File
```json
{
    "enabled": true,
    "tracked_functions": [
        "main",
        "DMA1_Stream2_IRQHandler"
    ],
    "frame_cost": 4,
    "allow_recursion": true,
    "allow_function_ptrs": true
}
```
### Example Report File
```json
{
    "total_function_nodes": 1220,
    "num_functions_known_local_stack": 1218,
    "num_functions_known_max_stack": 1215,
    "tracked_functions": [
        {
            "name": "main",
            "su_max": 1232
        },
        {
            "name": "DMA1_Stream2_IRQHandler",
            "su_max": 148
        }
    ],
    "unknown_local_su": [
        "Reset_Handler",
        "ADC3_IRQHandler"
    ],
    "unknown_max_su": [
        "QuadEncoders_Init",
        "QuadEncoders_Clear",
        "PopulateAccessTable",
        "MC_setDisabledSettings",
        "Reset_Handler"
    ],
    "missing_children": [
        "PDO_InputMapping",
        "xTaskCreateStatic.part.4",
        "memcpy",
        "malloc",
        "free",
        "memset",
        "__aeabi_uldivmod",
        "MainInit",
        "__libc_init_array"
    ]
}
```

## Run Against Example Build
Use this to run strack agains the example build included in `/example/`
`python3 strack.py . analyze example/Debug/Application/SW4STM32/startup_stm32h743xx.o example/Debug/Application/User/main.o example/Debug/Application/User/stm32h7xx_hal_timebase_tim.o example/Debug/Application/User/stm32h7xx_it.o example/Debug/Drivers/BSP/STM32H7xx_Nucleo/stm32h7xx_nucleo.o example/Debug/Drivers/CMSIS/system_stm32h7xx.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_adc.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_adc_ex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_cortex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_dma.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_dma_ex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_exti.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_gpio.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_i2c.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_i2c_ex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_pwr.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_pwr_ex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_rcc.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_rcc_ex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_tim.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_tim_ex.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_uart.o example/Debug/Drivers/STM32H7xx_HAL_Driver/stm32h7xx_hal_uart_ex.o example/Debug/Middlewares/FreeRTOS/CMSIS-RTOS/cmsis_os.o example/Debug/Middlewares/FreeRTOS/croutine.o example/Debug/Middlewares/FreeRTOS/event_groups.o example/Debug/Middlewares/FreeRTOS/list.o example/Debug/Middlewares/FreeRTOS/queue.o example/Debug/Middlewares/FreeRTOS/tasks.o example/Debug/Middlewares/FreeRTOS/timers.o example/Debug/Middlewares/FreeRTOS/portable/heap_4.o example/Debug/Middlewares/FreeRTOS/portable/port.o`

## C++
C++ is not currently supported.  Challenges needing to be overcome in order to support C++ are listed below:  
 - Name-mangling (a result of supporting namespaces and method overloading)
   - .o files contain name-mangled symbols, while .su files contain non-name-mangled method names with arg lists and return types.
   - This is further complicated because the method names in the .su files have user-declared data types before typedefs are applied so just applying name-mangling algorithms to these will not match them to their name-mangled counterparts in the .o files.
 - Virtual methods
   - Runtime polymorphism through virtual methods requires the use of function pointers which are not friendly to static analysis.
   - Extra logic would have to be added to categorize virtual methods so when a generic virtual method shows up in a call graph the analyzer can make a worst case judgement based on the possible virtual methods being invoked there.
